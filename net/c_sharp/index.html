



<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content=".net,java,php,python,docker,web">
      
      
        <link rel="canonical" href="https://burningmyself.gitee.io/net/c_sharp/">
      
      
        <meta name="author" content="BurningMyself">
      
      
        <meta name="lang:clipboard.copy" content="复制">
      
        <meta name="lang:clipboard.copied" content="已复制">
      
        <meta name="lang:search.language" content="zh,en,ja">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="没有找到符合条件的结果">
      
        <meta name="lang:search.result.one" content="找到 1 个符合条件的结果">
      
        <meta name="lang:search.result.other" content="# 个符合条件的结果">
      
        <meta name="lang:search.tokenizer" content="[\ s \-\ .. +">
      
      <link rel="shortcut icon" href="../../favicon.ico">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>C#新特性语法 - BurningMyself</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
        
<script>
  window.ga = window.ga || function() {
    (ga.q = ga.q || []).push(arguments)
  }
  ga.l = +new Date
  /* Setup integration and send page view */
  ga("create", "UA-155084439-1", "burningmyself.gitee.io")
  ga("set", "anonymizeIp", true)
  ga("send", "pageview")
  /* Register handler to log search on blur */
  document.addEventListener("DOMContentLoaded", () => {
    if (document.forms.search) {
      var query = document.forms.search.query
      query.addEventListener("blur", function() {
        if (this.value) {
          var path = document.location.pathname;
          ga("send", "pageview", path + "?q=" + this.value)
        }
      })
    }
  })
</script>
<script async src="https://www.google-analytics.com/analytics.js"></script>
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#c" tabindex="1" class="md-skip">
        跳转至
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="https://burningmyself.gitee.io" title="BurningMyself" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              BurningMyself
            </span>
            <span class="md-header-nav__topic">
              
                C#新特性语法
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            键入以开始搜索
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="https://github.com/burningmyself/burningmyself.github.io/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    burningmyself.github.io
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="https://burningmyself.gitee.io" title="BurningMyself" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    BurningMyself
  </label>
  
    <div class="md-nav__source">
      


  

<a href="https://github.com/burningmyself/burningmyself.github.io/" title="前往 Github 仓库" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    burningmyself.github.io
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="介绍" class="md-nav__link">
      介绍
    </a>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2" checked>
    
    <label class="md-nav__link" for="nav-2">
      技术博文
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        技术博文
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1" checked>
    
    <label class="md-nav__link" for="nav-2-1">
      .NET
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-1">
        .NET
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        C#新特性语法
      </label>
    
    <a href="./" title="C#新特性语法" class="md-nav__link md-nav__link--active">
      C#新特性语法
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c_6" class="md-nav__link">
    C# 6
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#string_interpolation" class="md-nav__link">
    一、字符串插值 （String Interpolation）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    二、空操作符 ( ?. )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nameof" class="md-nav__link">
    三、 NameOf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#catchfinallyawait" class="md-nav__link">
    四、在Catch和Finally里使用Await
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    五、表达式方法体
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    六、自动属性初始化器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    七、只读自动属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_filter" class="md-nav__link">
    八、异常过滤器 Exception Filter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    九、 Index 初始化器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using_static_using" class="md-nav__link">
    十、using 静态类的方法可以使用 static using
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_7" class="md-nav__link">
    C# 7
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    数字字面量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#out" class="md-nav__link">
    改进的out关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模式匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    值类型元组
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    元组的字段名称
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    元组作为方法的参数和返回值
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    相同类型元组的赋值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    解构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    元组的解构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    解构其他类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    忽略类型成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    使用扩展方法进行解构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    局部函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    更多的表达式体成员
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_8" class="md-nav__link">
    C# 8
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    可空引用类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async_streams" class="md-nav__link">
    异步流（Async streams）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    范围和下标类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    接口的默认实现方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    模式匹配表达式和递归模式语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    目标类型推导
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_9" class="md-nav__link">
    C# 9
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    仅可初始化的属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    初始化访问器和只读字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with" class="md-nav__link">
    With表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    基于值的相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    数据成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    位置记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    记录和修改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with_1" class="md-nav__link">
    with表达式和继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    基于值的相等性与继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    顶级程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    改进后的模式匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    简单类型模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    关系模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    逻辑模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    改进后的目标类型推断
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#new" class="md-nav__link">
    支持目标类型推断的new表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    目标类型的??与?:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    支持协变的返回值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../c_docker/" title=".Net Core Docker 部署" class="md-nav__link">
      .Net Core Docker 部署
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../c_sqlserver_nginx/" title="Docker 容器化部署 ASP.NET Core" class="md-nav__link">
      Docker 容器化部署 ASP.NET Core
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../c_core_safety/" title="让你的ASP.NET Core应用程序更安全" class="md-nav__link">
      让你的ASP.NET Core应用程序更安全
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../c_core_study_route/" title="ASP.NET Core开发者指南" class="md-nav__link">
      ASP.NET Core开发者指南
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-2" type="checkbox" id="nav-2-2">
    
    <label class="md-nav__link" for="nav-2-2">
      Java
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-2">
        Java
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/feature/" title="Java特性" class="md-nav__link">
      Java特性
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/load-class/" title="Java类加载" class="md-nav__link">
      Java类加载
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/orm/" title="Orm的优缺点" class="md-nav__link">
      Orm的优缺点
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/bio-nio/" title="BIO与NIO" class="md-nav__link">
      BIO与NIO
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/rocketmq/rmq-1/" title="RocketMq下载与安装" class="md-nav__link">
      RocketMq下载与安装
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/springAnnotation/" title="Spring常用注解" class="md-nav__link">
      Spring常用注解
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/javavm/" title="Java 虚拟机" class="md-nav__link">
      Java 虚拟机
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/springdesign/" title="Spring 常用设计" class="md-nav__link">
      Spring 常用设计
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/spring-cloud/" title="Spring Cloud" class="md-nav__link">
      Spring Cloud
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/java-simple/" title="Java simple" class="md-nav__link">
      Java simple
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/java-validator/" title="Java Validator" class="md-nav__link">
      Java Validator
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/java-string/" title="Java String" class="md-nav__link">
      Java String
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../java/java-utils/" title="Java Utils" class="md-nav__link">
      Java Utils
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-3" type="checkbox" id="nav-2-3">
    
    <label class="md-nav__link" for="nav-2-3">
      Python
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-3">
        Python
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../python/feature/" title="Python特性" class="md-nav__link">
      Python特性
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../python/str_joint/" title="Python字符拼接" class="md-nav__link">
      Python字符拼接
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../python/syntax_rule/" title="Python语法技巧" class="md-nav__link">
      Python语法技巧
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../python/fabric/" title="远程部署神器 Fabric" class="md-nav__link">
      远程部署神器 Fabric
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4" type="checkbox" id="nav-2-4">
    
    <label class="md-nav__link" for="nav-2-4">
      PHP
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-4">
        PHP
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../php/kj/" title="框架" class="md-nav__link">
      框架
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-5" type="checkbox" id="nav-2-5">
    
    <label class="md-nav__link" for="nav-2-5">
      Web
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-5">
        Web
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/es6/" title="es6语法" class="md-nav__link">
      es6语法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/ali_js_style/" title="阿里js样式规范" class="md-nav__link">
      阿里js样式规范
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/node.js/" title="node.js文档" class="md-nav__link">
      node.js文档
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/react/" title="React 开发者指南" class="md-nav__link">
      React 开发者指南
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../dart/syntax/" title="Dart语法学习" class="md-nav__link">
      Dart语法学习
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/react_interview/" title="React 面试" class="md-nav__link">
      React 面试
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/js_tool_method/" title="js 工具函数" class="md-nav__link">
      js 工具函数
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/vue_cp_react/" title="vue与react比较" class="md-nav__link">
      vue与react比较
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../web/javascript/" title="JavaScript 基础" class="md-nav__link">
      JavaScript 基础
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-6" type="checkbox" id="nav-2-6">
    
    <label class="md-nav__link" for="nav-2-6">
      SQL
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-6">
        SQL
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_yh/" title="MySQL优化" class="md-nav__link">
      MySQL优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_yh17/" title="MySQL优化" class="md-nav__link">
      MySQL优化
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_log/" title="MySQL日志" class="md-nav__link">
      MySQL日志
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_index/" title="MySQL索引" class="md-nav__link">
      MySQL索引
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_pxc/" title="MySQL PXC集群" class="md-nav__link">
      MySQL PXC集群
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_use/" title="MySQL 数据库应用" class="md-nav__link">
      MySQL 数据库应用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mysql_backups/" title="MySql 备份" class="md-nav__link">
      MySql 备份
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/sql_server_master/" title="Sql Server 主从备份" class="md-nav__link">
      Sql Server 主从备份
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/data_split/" title="数据库之互联网常用分库分表方案" class="md-nav__link">
      数据库之互联网常用分库分表方案
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../sql/mybatis/" title="Mybatis使用心德" class="md-nav__link">
      Mybatis使用心德
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-7" type="checkbox" id="nav-2-7">
    
    <label class="md-nav__link" for="nav-2-7">
      Linux
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-7">
        Linux
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../linux/often/" title="常用命令" class="md-nav__link">
      常用命令
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../linux/ope/" title="实用的Linux 命令" class="md-nav__link">
      实用的Linux 命令
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-8" type="checkbox" id="nav-2-8">
    
    <label class="md-nav__link" for="nav-2-8">
      Docker
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-8">
        Docker
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../docker/docker/" title="Docker全科" class="md-nav__link">
      Docker全科
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../docker/docker-compose/" title="docker和docker-compose配置常用环境" class="md-nav__link">
      docker和docker-compose配置常用环境
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../docker/docker-jenkins/" title="Docker部署Jenkins" class="md-nav__link">
      Docker部署Jenkins
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-9" type="checkbox" id="nav-2-9">
    
    <label class="md-nav__link" for="nav-2-9">
      Tool
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-9">
        Tool
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/git/" title="Git" class="md-nav__link">
      Git
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/gitquestion/" title="Git问题处理" class="md-nav__link">
      Git问题处理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/gitflow/" title="GitFlow" class="md-nav__link">
      GitFlow
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/gitbook/" title="GitBook" class="md-nav__link">
      GitBook
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/gitcmr/" title="Git提交日志规范" class="md-nav__link">
      Git提交日志规范
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/markdown/" title="Markdown" class="md-nav__link">
      Markdown
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/cicd/" title="CI/CD" class="md-nav__link">
      CI/CD
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/mkdocs/" title="mkdocs简单使用" class="md-nav__link">
      mkdocs简单使用
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/gitstudy/" title="Git的黑魔法" class="md-nav__link">
      Git的黑魔法
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../tool/minio/" title="MinIO 搭建使用" class="md-nav__link">
      MinIO 搭建使用
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      微服务
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        微服务
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/fbs-lock/" title="分布式锁" class="md-nav__link">
      分布式锁
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/design/" title="微服务设计" class="md-nav__link">
      微服务设计
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/distrimsg/" title="分布式系统与消息的投递" class="md-nav__link">
      分布式系统与消息的投递
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/ddd/" title="基于DDD的微服务设计和开发实战" class="md-nav__link">
      基于DDD的微服务设计和开发实战
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/kafka/" title="Kafka架构原理" class="md-nav__link">
      Kafka架构原理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/redis-cluster/" title="Redis Cluster原理" class="md-nav__link">
      Redis Cluster原理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../micro/spring-cloud-micro/" title="分布式架构" class="md-nav__link">
      分布式架构
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4">
    
    <label class="md-nav__link" for="nav-4">
      经验分析
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        经验分析
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/devops/" title="DevOps" class="md-nav__link">
      DevOps
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/micro-service/" title="Micro-Service" class="md-nav__link">
      Micro-Service
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/raft-gossip/" title="Raft算法和Gossip协议" class="md-nav__link">
      Raft算法和Gossip协议
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/cl/" title="集群和负载均衡" class="md-nav__link">
      集群和负载均衡
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/ai/" title="人工智能" class="md-nav__link">
      人工智能
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/code-principle/" title="代码原则" class="md-nav__link">
      代码原则
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/techbig/" title="如何成为技术大牛" class="md-nav__link">
      如何成为技术大牛
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/learnweetout/" title="程序员如何技术成长" class="md-nav__link">
      程序员如何技术成长
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/pt/" title="产品与技术" class="md-nav__link">
      产品与技术
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/four_deep_learning/" title="深度学习框架" class="md-nav__link">
      深度学习框架
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/tl/" title="在阿里做了5年技术Leader，我总结出这些套路！" class="md-nav__link">
      在阿里做了5年技术Leader，我总结出这些套路！
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../exp/cto/" title="CTO 技能图谱" class="md-nav__link">
      CTO 技能图谱
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      医学
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        医学
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../doctor/ae/" title="脑炎" class="md-nav__link">
      脑炎
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-6" type="checkbox" id="nav-6">
    
    <label class="md-nav__link" for="nav-6">
      构架
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-6">
        构架
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../framework/split/" title="构架拆分" class="md-nav__link">
      构架拆分
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../framework/fgb/" title="分布式、高并发、多线程" class="md-nav__link">
      分布式、高并发、多线程
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../framework/agility/" title="如何理解敏捷开发" class="md-nav__link">
      如何理解敏捷开发
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../framework/fwork/" title="走向架构师必备的技能" class="md-nav__link">
      走向架构师必备的技能
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../framework/data-middle/" title="数据中台的思考与总结" class="md-nav__link">
      数据中台的思考与总结
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-7" type="checkbox" id="nav-7">
    
    <label class="md-nav__link" for="nav-7">
      情感
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-7">
        情感
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/eq/" title="情商" class="md-nav__link">
      情商
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/workheard/" title="工作心得" class="md-nav__link">
      工作心得
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/lookbook/" title="看书" class="md-nav__link">
      看书
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/fmf/" title="4种男朋友" class="md-nav__link">
      4种男朋友
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/notheart/" title="不上心" class="md-nav__link">
      不上心
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/selfdiscipline/" title="自律" class="md-nav__link">
      自律
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/notlike/" title="喜欢与不喜欢" class="md-nav__link">
      喜欢与不喜欢
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/latemarry/" title="晚婚" class="md-nav__link">
      晚婚
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/understand/" title="追女生要明白这些事" class="md-nav__link">
      追女生要明白这些事
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/backup/" title="备胎" class="md-nav__link">
      备胎
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/chase/" title="为什么追不到她" class="md-nav__link">
      为什么追不到她
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/livefail/" title="为什么活着失败" class="md-nav__link">
      为什么活着失败
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/emotion/" title="情绪管理" class="md-nav__link">
      情绪管理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/abolish/" title="废掉的三个迹象" class="md-nav__link">
      废掉的三个迹象
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/uptime/" title="余生，好好珍惜" class="md-nav__link">
      余生，好好珍惜
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/losecome/" title="所有的失去，都会以另一种方式归来" class="md-nav__link">
      所有的失去，都会以另一种方式归来
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/threeheart/" title="人生有这三种好心态" class="md-nav__link">
      人生有这三种好心态
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/onelike/" title="一个感情真相" class="md-nav__link">
      一个感情真相
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/notruth/" title="情商与道理" class="md-nav__link">
      情商与道理
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/smf/" title="六种男人远离" class="md-nav__link">
      六种男人远离
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/select/" title="决定接下来人生归属的，不是努力，而是选择" class="md-nav__link">
      决定接下来人生归属的，不是努力，而是选择
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/nolike/" title="被你拉黑的那个人，你一定很喜欢吧" class="md-nav__link">
      被你拉黑的那个人，你一定很喜欢吧
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/onepath/" title="余生，学会一个人走，不管有没有人陪" class="md-nav__link">
      余生，学会一个人走，不管有没有人陪
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/twopath/" title="往后余生还很精彩，别被熬夜拖垮了" class="md-nav__link">
      往后余生还很精彩，别被熬夜拖垮了
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/lifetime/" title="心态好的人，一辈子都好" class="md-nav__link">
      心态好的人，一辈子都好
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/hearttoheart/" title="将心比心，方得人心" class="md-nav__link">
      将心比心，方得人心
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/ttt/" title="别睡太晚，别爱太满，别要太多" class="md-nav__link">
      别睡太晚，别爱太满，别要太多
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../emotion/profess/" title="表白" class="md-nav__link">
      表白
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">目录</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#c_6" class="md-nav__link">
    C# 6
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#string_interpolation" class="md-nav__link">
    一、字符串插值 （String Interpolation）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    二、空操作符 ( ?. )
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nameof" class="md-nav__link">
    三、 NameOf
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#catchfinallyawait" class="md-nav__link">
    四、在Catch和Finally里使用Await
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    五、表达式方法体
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    六、自动属性初始化器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    七、只读自动属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#exception_filter" class="md-nav__link">
    八、异常过滤器 Exception Filter
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#index" class="md-nav__link">
    九、 Index 初始化器
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#using_static_using" class="md-nav__link">
    十、using 静态类的方法可以使用 static using
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_7" class="md-nav__link">
    C# 7
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_5" class="md-nav__link">
    数字字面量
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#out" class="md-nav__link">
    改进的out关键字
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_6" class="md-nav__link">
    模式匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_7" class="md-nav__link">
    值类型元组
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_8" class="md-nav__link">
    元组的字段名称
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_9" class="md-nav__link">
    元组作为方法的参数和返回值
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_10" class="md-nav__link">
    相同类型元组的赋值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_11" class="md-nav__link">
    解构
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_12" class="md-nav__link">
    元组的解构
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_13" class="md-nav__link">
    解构其他类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_14" class="md-nav__link">
    忽略类型成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_15" class="md-nav__link">
    使用扩展方法进行解构
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_16" class="md-nav__link">
    局部函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_17" class="md-nav__link">
    更多的表达式体成员
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_8" class="md-nav__link">
    C# 8
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_18" class="md-nav__link">
    可空引用类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#async_streams" class="md-nav__link">
    异步流（Async streams）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_19" class="md-nav__link">
    范围和下标类型
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_20" class="md-nav__link">
    接口的默认实现方法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_21" class="md-nav__link">
    模式匹配表达式和递归模式语句
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_22" class="md-nav__link">
    目标类型推导
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#c_9" class="md-nav__link">
    C# 9
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_23" class="md-nav__link">
    仅可初始化的属性
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_24" class="md-nav__link">
    初始化访问器和只读字段
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_25" class="md-nav__link">
    记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with" class="md-nav__link">
    With表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_26" class="md-nav__link">
    基于值的相等
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_27" class="md-nav__link">
    数据成员
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_28" class="md-nav__link">
    位置记录
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_29" class="md-nav__link">
    记录和修改
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#with_1" class="md-nav__link">
    with表达式和继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_30" class="md-nav__link">
    基于值的相等性与继承
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_31" class="md-nav__link">
    顶级程序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_32" class="md-nav__link">
    改进后的模式匹配
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_33" class="md-nav__link">
    简单类型模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_34" class="md-nav__link">
    关系模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_35" class="md-nav__link">
    逻辑模式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_36" class="md-nav__link">
    改进后的目标类型推断
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#new" class="md-nav__link">
    支持目标类型推断的new表达式
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_37" class="md-nav__link">
    目标类型的??与?:
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_38" class="md-nav__link">
    支持协变的返回值
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="https://github.com/burningmyself/burningmyself.github.io/edit/master/docs/net/c_sharp.md" title="编辑此页" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="c">C# 新特性<a class="headerlink" href="#c" title="Permanent link">&para;</a></h1>
<h2 id="c_6">C# 6<a class="headerlink" href="#c_6" title="Permanent link">&para;</a></h2>
<h3 id="string_interpolation">一、字符串插值 （String Interpolation）<a class="headerlink" href="#string_interpolation" title="Permanent link">&para;</a></h3>
<p>C# 6之前我们拼接字符串时需要这样
<div class="codehilite"><pre><span></span> <span class="kt">var</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">;</span>
 <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="s">&quot;Hello&quot;</span> <span class="p">+</span> <span class="n">Name</span><span class="p">;</span>
</pre></div>
或者
<div class="codehilite"><pre><span></span> <span class="kt">var</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">;</span>
 <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;Hello {0}&quot;</span><span class="p">,</span> <span class="n">Name</span><span class="p">);</span>
</pre></div>
但是C#6里我们就可以使用新的字符串插值特性
<div class="codehilite"><pre><span></span>  <span class="kt">var</span> <span class="n">Name</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">;</span>
  <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="err">$</span><span class="s">&quot;Hello {Name}&quot;</span><span class="p">;</span>
</pre></div>
上面只是一个简单的例子，想想如果有多个值要替换的话，用C#6的这个新特性，代码就会大大减小，而且可读性比起之前大大增强
<div class="codehilite"><pre><span></span> <span class="n">Person</span> <span class="n">p</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Person</span> <span class="p">{</span><span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">,</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Wang&quot;</span><span class="p">,</span> <span class="n">Age</span> <span class="p">=</span> <span class="m">100</span><span class="p">};</span>
 <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="kt">string</span><span class="p">.</span><span class="n">Format</span><span class="p">(</span><span class="s">&quot;First Name: {0} LastName: {1} Age: { 2} &quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">LastName</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">Age</span><span class="p">);</span>
</pre></div>
有了字符串插值后:
<div class="codehilite"><pre><span></span> <span class="kt">var</span> <span class="n">results</span> <span class="p">=</span> <span class="err">$</span><span class="s">&quot;First Name: {p.FirstName} LastName: {p.LastName} Age: {p.Age}&quot;</span><span class="p">;</span>
</pre></div>
字符串插值不光是可以插简单的字符串，还可以直接插入代码
<div class="codehilite"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;Jack is saying { new Tools().SayHello() }&quot;</span><span class="p">);</span>

<span class="kt">var</span> <span class="n">info</span> <span class="p">=</span> <span class="err">$</span><span class="s">&quot;Your discount is {await GetDiscount()}&quot;</span><span class="p">;</span>
</pre></div>
那么如何处理多语言呢？我们可以使用 IFormattable下面的代码如何实现多语言？
<div class="codehilite"><pre><span></span> <span class="n">Double</span> <span class="n">remain</span> <span class="p">=</span> <span class="m">2000.5</span><span class="p">;</span> 
 <span class="kt">var</span> <span class="n">results</span><span class="p">=</span> <span class="err">$</span><span class="s">&quot;your money is {remain:C}&quot;</span><span class="p">;</span>  
</pre></div>
输出 your money is $2,000.50</p>
<p>使用IFormattable 多语言
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">Double</span> <span class="n">remain</span> <span class="p">=</span> <span class="m">2000.5</span><span class="p">;</span> 

       <span class="kt">var</span> <span class="n">results</span><span class="p">=</span> <span class="n">ChineseText</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;your money is {remain:C}&quot;</span><span class="p">);</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">results</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Read</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">ChineseText</span><span class="p">(</span><span class="n">IFormattable</span> <span class="n">formattable</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">formattable</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">new</span> <span class="n">CultureInfo</span><span class="p">(</span><span class="s">&quot;zh-cn&quot;</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
输出  your money is ￥2,000.50</p>
<h3 id="_1">二、空操作符 ( ?. )<a class="headerlink" href="#_1" title="Permanent link">&para;</a></h3>
<p>C# 6添加了一个 ?. 操作符，当一个对象或者属性职为空时直接返回null, 就不再继续执行后面的代码，在之前我们的代码里经常出现 NullException, 所以我们就需要加很多Null的判断，比如
<div class="codehilite"><pre><span></span> <span class="k">if</span> <span class="p">(</span><span class="n">user</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="n">Project</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="n">Project</span><span class="p">.</span><span class="n">Tasks</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="n">Project</span><span class="p">.</span><span class="n">Tasks</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
 <span class="p">{</span>
   <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">user</span><span class="p">.</span><span class="n">Project</span><span class="p">.</span><span class="n">Tasks</span><span class="p">.</span><span class="n">First</span><span class="p">().</span><span class="n">Name</span><span class="p">);</span>
 <span class="p">}</span>
</pre></div>
现在我们可以不用写 IF 直接写成如下这样
<div class="codehilite"><pre><span></span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">user</span><span class="p">?.</span><span class="n">Project</span><span class="p">?.</span><span class="n">Tasks</span><span class="p">?.</span><span class="n">First</span><span class="p">()?.</span><span class="n">Name</span><span class="p">);</span>
</pre></div>
这个?. 特性不光是可以用于取值，也可以用于方法调用，如果对象为空将不进行任何操作，下面的代码不会报错，也不会有任何输出。
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">User</span> <span class="n">user</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="n">user</span><span class="p">?.</span><span class="n">SayHello</span><span class="p">();</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">Read</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">public</span> <span class="k">class</span> <span class="nc">User</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">SayHello</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Ha Ha&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
还可以用于数组的索引器
<div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">User</span><span class="p">[]</span> <span class="n">users</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;</span> <span class="n">listUsers</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

        <span class="c1">// Console.WriteLine(users[1]?.Name); // 报错</span>
        <span class="c1">// Console.WriteLine(listUsers[1]?.Name); //报错</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">users</span><span class="p">?[</span><span class="m">1</span><span class="p">].</span><span class="n">Name</span><span class="p">);</span> <span class="c1">// 正常</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">listUsers</span><span class="p">?[</span><span class="m">1</span><span class="p">].</span><span class="n">Name</span><span class="p">);</span> <span class="c1">// 正常</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
注意： 上面的代码虽然可以让我们少些很多代码，而且也减少了空异常，但是我们却需要小心使用，因为有的时候我们确实是需要抛出空异常，那么使用这个特性反而隐藏了Bug</p>
<h3 id="nameof">三、 NameOf<a class="headerlink" href="#nameof" title="Permanent link">&para;</a></h3>
<p>过去，我们有很多的地方需要些硬字符串，导致重构比较困难，而且一旦敲错字母很难察觉出来，比如
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">role</span> <span class="p">==</span> <span class="s">&quot;admin&quot;</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
WPF 也经常有这样的代码
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span>
<span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">set</span>
  <span class="p">{</span>
      <span class="n">name</span><span class="p">=</span> <span class="k">value</span><span class="p">;</span>
      <span class="n">RaisePropertyChanged</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
现在有了C#6 NameOf后，我们可以这样
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="kt">string</span> <span class="n">Name</span>
<span class="p">{</span>
  <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">set</span>
  <span class="p">{</span>
      <span class="n">name</span><span class="p">=</span> <span class="k">value</span><span class="p">;</span>
      <span class="n">RaisePropertyChanged</span><span class="p">(</span><span class="n">NameOf</span><span class="p">(</span><span class="n">Name</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">Name</span><span class="p">));</span> <span class="c1">//  output: Name</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">System</span><span class="p">.</span><span class="n">Linq</span><span class="p">));</span> <span class="c1">// output: Linq</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">List</span><span class="p">&lt;</span><span class="n">User</span><span class="p">&gt;));</span> <span class="c1">// output: List</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
注意： NameOf只会返回Member的字符串，如果前面有对象或者命名空间，NameOf只会返回 . 的最后一部分, 另外NameOf有很多情况是不支持的，比如方法，关键字，对象的实例以及字符串和表达式</p>
<h3 id="catchfinallyawait">四、在Catch和Finally里使用Await<a class="headerlink" href="#catchfinallyawait" title="Permanent link">&para;</a></h3>
<p>在之前的版本里，C#开发团队认为在Catch和Finally里使用Await是不可能，而现在他们在C#6里实现了它。
<div class="codehilite"><pre><span></span><span class="n">Resource</span> <span class="n">res</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
<span class="k">try</span>
<span class="p">{</span>
    <span class="n">res</span> <span class="p">=</span> <span class="k">await</span> <span class="n">Resource</span><span class="p">.</span><span class="n">OpenAsync</span><span class="p">();</span> <span class="c1">// You could always do this.  </span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">ResourceException</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="n">Resource</span><span class="p">.</span><span class="n">LogAsync</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span> <span class="c1">// Now you can do this … </span>
<span class="p">}</span> 
<span class="k">finally</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">res</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span> <span class="k">await</span> <span class="n">res</span><span class="p">.</span><span class="n">CloseAsync</span><span class="p">();</span> <span class="c1">// … and this.</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="_2">五、表达式方法体<a class="headerlink" href="#_2" title="Permanent link">&para;</a></h3>
<p>一句话的方法体可以直接写成箭头函数，而不再需要大括号
<div class="codehilite"><pre><span></span> <span class="k">class</span> <span class="nc">Program</span>
 <span class="p">{</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">SayHello</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="s">&quot;Hello World&quot;</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">JackSayHello</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="err">$</span><span class="s">&quot;Jack {SayHello()}&quot;</span><span class="p">;</span>

    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">SayHello</span><span class="p">());</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">JackSayHello</span><span class="p">());</span>

        <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="_3">六、自动属性初始化器<a class="headerlink" href="#_3" title="Permanent link">&para;</a></h3>
<p>之前我们需要赋初始化值，一般需要这样
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">public</span> <span class="nf">Person</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Age</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
但是C# 6的新特性里我们这样赋值
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="_4">七、只读自动属性<a class="headerlink" href="#_4" title="Permanent link">&para;</a></h3>
<p>C# 1里我们可以这样实现只读属性
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="kt">int</span> <span class="n">age</span><span class="p">=</span><span class="m">100</span><span class="p">;</span>

    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">age</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
但是当我们有自动属性时，我们没办法实行只读属性，因为自动属性不支持readonly关键字，所以我们只能缩小访问权限
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span>  <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

<span class="p">}</span>
</pre></div>
但是 C#6里我们可以实现readonly的自动属性了
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span> <span class="p">=</span> <span class="m">100</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="exception_filter">八、异常过滤器 Exception Filter<a class="headerlink" href="#exception_filter" title="Permanent link">&para;</a></h3>
<p><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">throw</span>  <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;Age&quot;</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentException</span> <span class="n">argumentException</span><span class="p">)</span> <span class="n">when</span><span class="p">(</span> <span class="n">argumentException</span><span class="p">.</span><span class="n">Message</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;Name&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">throw</span>  <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">&quot;Name Exception&quot;</span><span class="p">);</span>

    <span class="p">}</span>

    <span class="k">catch</span> <span class="p">(</span><span class="n">ArgumentException</span> <span class="n">argumentException</span><span class="p">)</span> <span class="n">when</span><span class="p">(</span> <span class="n">argumentException</span><span class="p">.</span><span class="n">Message</span><span class="p">.</span><span class="n">Equals</span><span class="p">(</span><span class="s">&quot;Age&quot;</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">&quot;not handle&quot;</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="k">catch</span>  <span class="p">(</span><span class="n">Exception</span> <span class="n">e</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="k">throw</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
在之前，一种异常只能被Catch一次，现在有了Filter后可以对相同的异常进行过滤，至于有什么用，那就是见仁见智了，我觉得上面的例子，定义两个具体的异常 NameArgumentException 和AgeArgumentException代码更易读。</p>
<h3 id="index">九、 Index 初始化器<a class="headerlink" href="#index" title="Permanent link">&para;</a></h3>
<p>这个主要是用在Dictionary上，至于有什么用，我目前没感觉到有一点用处，谁能知道很好的使用场景，欢迎补充:
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">names</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span>
<span class="p">{</span>
<span class="na">    [1]</span> <span class="p">=</span> <span class="s">&quot;Jack&quot;</span><span class="p">,</span>
<span class="na">    [2]</span> <span class="p">=</span> <span class="s">&quot;Alex&quot;</span><span class="p">,</span>
<span class="na">    [3]</span> <span class="p">=</span> <span class="s">&quot;Eric&quot;</span><span class="p">,</span>
<span class="na">    [4]</span> <span class="p">=</span> <span class="s">&quot;Jo&quot;</span>
<span class="p">};</span>

<span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">item</span> <span class="k">in</span> <span class="n">names</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;{item.Key} = {item.Value}&quot;</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></p>
<h3 id="using_static_using">十、using 静态类的方法可以使用 static using<a class="headerlink" href="#using_static_using" title="Permanent link">&para;</a></h3>
<p>这个功能在我看来，同样是很没有用的功能，也为去掉前缀有的时候我们不知道这个是来自哪里的，而且如果有一个同名方法不知道具体用哪个，当然经证实是使用类本身的覆盖，但是容易搞混不是吗？
<div class="codehilite"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">static</span> <span class="n">System</span><span class="p">.</span><span class="n">Math</span><span class="p">;</span>
<span class="k">namespace</span> <span class="nn">CSharp6NewFeatures</span>
 <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Program</span>
  <span class="p">{</span>
      <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">Log10</span><span class="p">(</span><span class="m">5</span><span class="p">)+</span><span class="n">PI</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></p>
<h2 id="c_7">C# 7<a class="headerlink" href="#c_7" title="Permanent link">&para;</a></h2>
<h3 id="_5">数字字面量<a class="headerlink" href="#_5" title="Permanent link">&para;</a></h3>
<p>现在可以在数字中加下划线，增加数字的可读性。编译器或忽略所有数字中的下划线
<div class="codehilite"><pre><span></span><span class="kt">int</span> <span class="n">million</span> <span class="p">=</span> <span class="m">1</span><span class="n">_000_000</span><span class="p">;</span>
</pre></div>
虽然编译器允许在数字中任意位置添加任意个数的下划线，但显然，遵循管理，下划线应该每三位使用一次，而且，不可以将下划线放在数字的开头（<em>1000）或结尾（1000</em>）</p>
<h3 id="out">改进的out关键字<a class="headerlink" href="#out" title="Permanent link">&para;</a></h3>
<p>C#7支持了out关键字的即插即用</p>
<p><div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="kt">int</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="s">&quot;345&quot;</span><span class="p">,</span> <span class="k">out</span> <span class="n">a</span><span class="p">);</span>

<span class="c1">// 就地使用变量作为返回值</span>
<span class="kt">int</span><span class="p">.</span><span class="n">TryParse</span><span class="p">(</span><span class="s">&quot;345&quot;</span><span class="p">,</span> <span class="kt">int</span> <span class="k">out</span> <span class="n">b</span><span class="p">);</span>
</pre></div>
允许以_（下划线）形式“舍弃”某个out参数，方便你忽略不关系的参数。例如下面的例子中，获得一个二维坐标的X可以重用获得二维坐标的X，Y方法，并舍弃掉Y：</p>
<div class="codehilite"><pre><span></span><span class="k">struct</span> <span class="nc">Point</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">void</span> <span class="nf">GetCoordinates</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">x</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="n">y</span> <span class="p">=</span> <span class="k">this</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">GetX</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// y被舍弃了，虽然GetCoordinates方法还是会传入2个变量，且执行y=this.y</span>
        <span class="c1">// 但它会在返回之后丢失</span>
        <span class="n">GetCoordinates</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">out</span> <span class="n">_</span><span class="p">);</span>
        <span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;({x})&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="_6">模式匹配<a class="headerlink" href="#_6" title="Permanent link">&para;</a></h3>
<p>模式匹配（Pattern matching）是C#7中引入的重要概念，它是之前is和case关键字的扩展。目前，C#拥有三种模式：</p>
<ul>
<li>常量模式：简单地判断某个变量是否等于一个常量（包括null）</li>
<li>类型模式：简单地判断某个变量是否为一个类型的实例</li>
<li>变量模式：临时引入一个新的某个类型的变量（C#7新增）</li>
</ul>
<p>下面的例子简单地演示了这三种模式：</p>
<p><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">People</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">TotalMoney</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="nf">People</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">TotalMoney</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">peopleList</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="n">People</span><span class="p">&gt;()</span> <span class="p">{</span>
            <span class="k">new</span> <span class="nf">People</span><span class="p">(</span><span class="m">1</span><span class="p">),</span>
            <span class="k">new</span> <span class="nf">People</span><span class="p">(</span><span class="m">1</span><span class="n">_000_000</span><span class="p">)</span>
        <span class="p">};</span>
        <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">p</span> <span class="k">in</span> <span class="n">peopleList</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// 类型模式</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="k">is</span> <span class="n">People</span><span class="p">)</span> <span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;是人&quot;</span><span class="p">);</span>
            <span class="c1">// 常量模式</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">TotalMoney</span> <span class="p">&gt;</span> <span class="m">500</span><span class="n">_000</span><span class="p">)</span> <span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;有钱&quot;</span><span class="p">);</span>
            <span class="c1">// 变量模式</span>
            <span class="c1">// 加入你需要先判断一个变量p是否为People，如果是，则再取它的TotalMoney字段</span>
            <span class="c1">// 那么在之前的版本中必须要分开写</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="k">is</span> <span class="n">People</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="p">(</span><span class="n">People</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">TotalMoney</span> <span class="p">&gt;</span> <span class="m">500</span><span class="n">_000</span><span class="p">)</span> <span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;有钱&quot;</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="c1">// 变量模式允许你引入一个变量并立即使用它</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="k">is</span> <span class="n">People</span> <span class="n">ppl</span> <span class="p">&amp;&amp;</span> <span class="n">ppl</span><span class="p">.</span><span class="n">TotalMoney</span> <span class="p">&gt;</span> <span class="m">500</span><span class="n">_000</span><span class="p">)</span> <span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;有钱&quot;</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">ReadKey</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
可以看出，变量模式引入的临时变量ppl（称为模式变量）的作用域也是整个if语句体，它的类型是People类型
case关键字也得到了改进。现在，case后面也允许模式变量，还允许when子句，代码如下：</p>
<p><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="m">13</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// 现在i就是a</span>
        <span class="c1">// 由于现在case后面可以跟when子句的表达式，不同的case有机会相交</span>
        <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span> <span class="n">i</span> <span class="p">%</span> <span class="m">2</span> <span class="p">==</span> <span class="m">1</span><span class="p">:</span>
            <span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="s">&quot; 是奇数&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">// 只会匹配第一个case，所以这个分支无法到达</span>
        <span class="k">case</span> <span class="kt">int</span> <span class="n">i</span> <span class="n">when</span>  <span class="n">i</span> <span class="p">&gt;</span> <span class="m">10</span><span class="p">:</span>
            <span class="n">WriteLine</span><span class="p">(</span><span class="n">i</span> <span class="p">+</span> <span class="s">&quot; 大于10&quot;</span><span class="p">);</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="c1">// 永远在最后被检查，即使它后面还有case子句</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
上面的代码运行的结果是打印出13是奇数，我们可以看到，现在case功能非常强大，可以匹配更具体、跟他特定的范围。不过，多个case的范围重叠，编译器只会选择第一个匹配上的分支</p>
<h3 id="_7">值类型元组<a class="headerlink" href="#_7" title="Permanent link">&para;</a></h3>
<p>元组（Tuple）的概念早在C#4就提出来，它是一个任意类型变量的集合，并最多支持8个变量。在我们不打算手写一个类型或结构体来盛放一个变量集合时（例如，它是临时的且用完即弃），或者打算从一个方法中返回多个值，我们会考虑使用元组。不过相比C#7的元组，C#4的元组更像一个半成品，先看看C#4如何使用元组：</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">beforeTuple</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Tuple</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;(</span><span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
<span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">beforeTuple</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span>
</pre></div>

<p>通过上面的代码发现，C#4中元组最大的两个问题是：</p>
<ul>
<li>Tuple类将其属性命名为Item1、Item2等，这些名称是无法改变的，只会让代码可读性变差</li>
<li>Tuple是引用类型，使用任一Tuple类意味着在堆上分配对象，因此，会对性能造成负面影响</li>
</ul>
<p>C#7引入的新元组（ValueTuple）解决了上面两个问题，它是一个结构体，并且你可以传入描述性名称（TupleElementNames属性）以便更容易地调用他们</p>
<p><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 未命名的元组，访问方式和之前的元组相同</span>
    <span class="kt">var</span> <span class="n">unnamed</span> <span class="p">=</span> <span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">unnamed</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span>
    <span class="c1">// 带有命名的元组</span>
    <span class="kt">var</span> <span class="n">named</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">:</span> <span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="n">second</span> <span class="p">:</span> <span class="s">&quot;two&quot;</span><span class="p">);</span>
    <span class="n">b</span> <span class="p">=</span> <span class="n">named</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
在背后，他们被编译器隐式地转化为：</p>
<p><div class="codehilite"><pre><span></span><span class="n">ValueTuple</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">unnamed</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ValueTuple</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span> <span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">);</span>
<span class="kt">string</span> <span class="n">b</span> <span class="p">=</span> <span class="n">unnamed</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span>
<span class="n">ValueTuple</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;</span> <span class="n">named</span> <span class="p">=</span> <span class="k">new</span> <span class="n">ValueTuple</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">&gt;()</span> <span class="p">(</span><span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="s">&quot;two&quot;</span><span class="p">);</span>
<span class="n">b</span> <span class="p">=</span> <span class="n">named</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span>
</pre></div>
我们看到，编译器将带有命名元组的实名访问转换成对应的Item，转换是使用特性实现的</p>
<h4 id="_8">元组的字段名称<a class="headerlink" href="#_8" title="Permanent link">&para;</a></h4>
<p>可以在元组定义时传入变量。此时，元组的字段名称为变量名。如果没有指明字段名称，又传入了常量，则只能使用Item1、Item2等访问元组的成员</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">localVariableOne</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
    <span class="kt">var</span> <span class="n">localVariableTwo</span> <span class="p">=</span> <span class="s">&quot;some text&quot;</span><span class="p">;</span>
    <span class="c1">// 显示实现的字段名称覆盖变量名</span>
    <span class="kt">var</span> <span class="n">tuple</span> <span class="p">=</span> <span class="p">(</span><span class="n">explicitFieldOne</span> <span class="p">:</span> <span class="n">localVariableOne</span><span class="p">,</span> <span class="n">explicitFieldTwo</span> <span class="p">:</span> <span class="n">localVariableTwo</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="n">tuple</span><span class="p">.</span><span class="n">explicitFieldOne</span><span class="p">;</span>

    <span class="c1">// 没有指定字段名称，又传入了变量名（需要C#7.1版本）</span>
    <span class="kt">var</span> <span class="n">tuple2</span> <span class="p">=</span> <span class="p">(</span><span class="n">localVariableOne</span><span class="p">,</span> <span class="n">localVariableTwo</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="n">tuple</span><span class="p">.</span><span class="n">localVariableOne</span><span class="p">;</span>

    <span class="c1">// 如果没有指明字段名称，又传入了常量，则只能使用Item1、Item2等访问元组的成员</span>
    <span class="kt">var</span> <span class="n">tuple3</span> <span class="p">=</span> <span class="p">(</span><span class="m">5</span><span class="p">,</span> <span class="s">&quot;some text&quot;</span><span class="p">);</span>
    <span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="n">tuple3</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>上面的代码给出了元组字段名称的优先级：</p>
<ul>
<li>首先是显示实现</li>
<li>其次是变量名（编译器自动推断的，需要C#7.1）</li>
<li>最后是默认的Item1、Item2作为保留名称</li>
</ul>
<p>另外，如果变量名或显示指定的描述名称是C#的关键字，则C#会改用ItemX作为字段名称（否则就会导致语法错误，例如将变量名为ToString的变量传入元组）</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">ToString</span> <span class="p">=</span> <span class="s">&quot;1&quot;</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">Item1</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">tuple4</span> <span class="p">=</span> <span class="p">(</span><span class="n">ToString</span><span class="p">,</span> <span class="n">Item1</span><span class="p">);</span>

<span class="c1">// ToString不能用作元组字段名称，强制改为Item1</span>
<span class="kt">var</span> <span class="n">d</span> <span class="p">=</span> <span class="n">tuple4</span><span class="p">.</span><span class="n">Item1</span><span class="p">;</span> <span class="c1">// &quot;1&quot;</span>
<span class="c1">// Item1不能用作元组字段名，强制改为Item2</span>
<span class="kt">var</span> <span class="n">e</span> <span class="p">=</span> <span class="n">tuple4</span><span class="p">.</span><span class="n">Item2</span><span class="p">;</span> <span class="c1">// 2</span>
<span class="n">ReadKey</span><span class="p">();</span>
</pre></div>

<h3 id="_9">元组作为方法的参数和返回值<a class="headerlink" href="#_9" title="Permanent link">&para;</a></h3>
<p>因为元组实际上是一个结构体，所以它当然可以作为方法的参数和返回值。因此，我们就有了可以返回多个变量的最简单、最优雅的方法（比使用out的可读性好很多）：</p>
<div class="codehilite"><pre><span></span><span class="c1">// 使用元组作方法的参数和返回值</span>
<span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span> <span class="n">MultiplyAll</span><span class="p">(</span><span class="kt">int</span> <span class="n">multiplier</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="n">members</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 元组没有实现IEnumerator接口，不能foreach</span>
    <span class="c1">// foreach(var a in members)</span>
    <span class="c1">// 操作元组</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">members</span><span class="p">.</span><span class="n">a</span> <span class="p">*</span> <span class="n">multiplier</span><span class="p">,</span> <span class="n">members</span><span class="p">.</span><span class="n">b</span> <span class="p">*</span> <span class="n">multiplier</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>

<p>上面代码中的方法会将输入中的a和b都乘以multiplier，然后返回结构。由于元组是结构体，所以即使含有引用类型，其值类型的部分也会在栈上进行分配，相比C#4的元组，C#7中的元组有着更好的性能和更友好的访问方式</p>
<h4 id="_10">相同类型元组的赋值<a class="headerlink" href="#_10" title="Permanent link">&para;</a></h4>
<p>如果它们的基数（即成员数）相同，且每个元素的类型要么相同，要么可以实现隐式转换，则两个元组被看作相同的类型：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">a</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span> <span class="p">:</span> <span class="s">&quot;one&quot;</span><span class="p">,</span> <span class="n">second</span> <span class="p">:</span> <span class="m">1</span><span class="p">);</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
    <span class="kt">var</span> <span class="n">b</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="s">&quot;hello&quot;</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="m">2</span><span class="p">);</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">b</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>
    <span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="p">(</span><span class="n">a</span> <span class="p">:</span> <span class="m">3</span><span class="p">,</span> <span class="n">b</span> <span class="p">:</span> <span class="s">&quot;world&quot;</span><span class="p">);</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span>

    <span class="n">WriteLine</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span> <span class="p">==</span> <span class="n">b</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span> <span class="c1">// True，两个元组基数和类型相同</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">GetType</span><span class="p">()</span> <span class="p">==</span> <span class="n">c</span><span class="p">.</span><span class="n">GetType</span><span class="p">());</span> <span class="c1">// False，两个元组基数相同但类型不同</span>

    <span class="p">(</span><span class="kt">string</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="n">d</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// 属性first，second消失了，取而代之的是a和b</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">a</span><span class="p">);</span>
    <span class="c1">// 定义了一个新的元组，成员为string和object类型</span>
    <span class="p">(</span><span class="kt">string</span> <span class="n">a</span><span class="p">,</span> <span class="kt">object</span> <span class="n">b</span><span class="p">)</span> <span class="n">e</span><span class="p">;</span>
    <span class="c1">// 由于int可以被隐式转换为object，所以可以这样赋值</span>
    <span class="n">e</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<h3 id="_11">解构<a class="headerlink" href="#_11" title="Permanent link">&para;</a></h3>
<p>C#7允许你定义结构方法（Deconstructor），注意，它和C#诞生即存在的析构函数（Destructor）不同。解构函数和构造函数做的事情某种程度上是相对的——构造函数将若干个类型组合为一个大的类型，而结构方法将大类型拆散为一堆小类型，这些小类型可以是单个字段，也可以是元组。当类型成员很多而需要的部分通常较小时，解构方法会很有用，它可以防止类型传参时复制的高昂代价</p>
<h4 id="_12">元组的解构<a class="headerlink" href="#_12" title="Permanent link">&para;</a></h4>
<p>可以在括号内显示地声明每个字段的类型，为元组中的每个元素创建离散变量，也可以用var关键字</p>
<p><div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 定义元组</span>
    <span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sumOfSquares</span><span class="p">)</span> <span class="n">tuple</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
    <span class="c1">// 使用方差的计算公式得到方差</span>
    <span class="kt">var</span> <span class="n">variance</span> <span class="p">=</span> <span class="n">tuple</span><span class="p">.</span><span class="n">sumOfSquares</span> <span class="p">-</span> <span class="n">tuple</span><span class="p">.</span><span class="n">sum</span> <span class="p">*</span> <span class="n">tuple</span><span class="p">.</span><span class="n">sum</span> <span class="p">/</span> <span class="n">tuple</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>

    <span class="c1">// 将一个元组放在等号右边，将对应的变量值和类型放在等号左边，就会导致解构</span>
    <span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sumOfSquares</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
    <span class="c1">// 解构之后的方差计算，代码简洁美观</span>
    <span class="n">variance</span> <span class="p">=</span> <span class="n">sumOfSquares</span> <span class="p">-</span> <span class="n">sum</span> <span class="p">*</span> <span class="n">sum</span> <span class="p">/</span> <span class="n">count</span><span class="p">;</span>
    <span class="c1">// 也可以这样解构，这会导致编译器推断元组的类型为三个int</span>
    <span class="kt">var</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
上面的代码中，出现了两次解构方法的隐式调用：左边是一个没有元组变量名的元组（只有一些成员变量名），右边是元组的实例。解构方法所做的事情，就是将右边元组的实例中每个成员，逐个指派给左边元组的成员变量。例如：</p>
<div class="codehilite"><pre><span></span><span class="p">(</span><span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sum</span><span class="p">,</span> <span class="kt">double</span> <span class="n">sumOfSquares</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">);</span>
</pre></div>

<p>就会使得count，sum和sumOfSquares的值分别为1，2，3。如果没有这个功能，就需要定义3个变量，然后赋值3次，最终得到6行代码，大大提高了代码的可读性。
对于元组，C#提供了内置的解构支持，因此不需要手动写解构方法，如果需要对非元组类型进行解构，就需要定义自己的解构方法，显而易见，上面的解构通过如下的签名的函数完成：</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="k">out</span> <span class="kt">double</span> <span class="n">sum</span><span class="p">,</span> <span class="k">out</span> <span class="kt">double</span> <span class="n">sumOfSquares</span><span class="p">)</span>
</pre></div>

<h4 id="_13">解构其他类型<a class="headerlink" href="#_13" title="Permanent link">&para;</a></h4>
<p>解构函数的名称必须为Deconstruct，下面的例子从一个较大的类型People中解构出我们想要的三项成员：</p>
<div class="codehilite"><pre><span></span><span class="c1">// 示例类型</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">People</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">MiddleName</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Age</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">CompanyName</span><span class="p">;</span>
    <span class="c1">// 解构全名，包括姓、名字和中间名</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">out</span> <span class="kt">string</span> <span class="n">f</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">m</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">l</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f</span> <span class="p">=</span> <span class="n">FirstName</span><span class="p">;</span>
        <span class="n">m</span> <span class="p">=</span> <span class="n">MiddleName</span><span class="p">;</span>
        <span class="n">l</span> <span class="p">=</span> <span class="n">LastName</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span>  <span class="n">p</span> <span class="p">=</span> <span class="n">People</span><span class="p">();</span>
    <span class="n">p</span><span class="p">.</span><span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Test&quot;</span><span class="p">;</span>
    <span class="kt">var</span> <span class="p">(</span><span class="n">fName</span><span class="p">,</span> <span class="n">mName</span><span class="p">,</span> <span class="n">lName</span><span class="p">)</span> <span class="p">=</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">fName</span><span class="p">);</span>

    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>

<p>解构方法不能有返回值，且要解构的每个成员必须以out标识出来。如果编译器对一个类型的实例解构，却没发现对应的解构函数，就会发生编译时异常。如果在解构时发生隐式类型转换，则不会发生编译时异常，例如将上述的解构函数的输入参数类型都改为object类型，仍然可以完成解构，可以通过**重载解构函数对类型实现不同方式的解构**</p>
<h4 id="_14">忽略类型成员<a class="headerlink" href="#_14" title="Permanent link">&para;</a></h4>
<p>为了少写代码，我们可以在解构时忽略类型成员。例如，我们如果只关系People的姓和名字，而不关心中间名，则不需要多写一个解构函数，而是利用现有的：</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="p">(</span><span class="n">fName</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">lName</span><span class="p">)</span> <span class="p">=</span> <span class="n">p</span><span class="p">;</span>
</pre></div>

<p>通过使用下划线来忽略类型成员，此时仍然会调用带有三个参数的解构函数，但是p将会只有fName和lName两个成员元组也支持忽略类型成员的解构</p>
<h4 id="_15">使用扩展方法进行解构<a class="headerlink" href="#_15" title="Permanent link">&para;</a></h4>
<p>即使类型并非由自己定义，仍然可以通过解构扩展方法来解构类型，例如解构.NET自带的DateTime类型：</p>
<p><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">d</span> <span class="p">=</span> <span class="n">DateTime</span><span class="p">.</span><span class="n">Now</span><span class="p">;</span>
        <span class="p">(</span><span class="kt">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">DayOfWeek</span> <span class="n">dow</span><span class="p">)</span> <span class="p">=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;今天是 {s}, 是 {d}&quot;</span><span class="p">);</span>
        <span class="n">ReadKey</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">ReflectionExtensions</span>
<span class="p">{</span>
    <span class="c1">// 解构DateTime并获得想要的值</span>
    <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">this</span> <span class="n">DateTime</span> <span class="n">dateTime</span><span class="p">,</span> <span class="k">out</span> <span class="kt">string</span> <span class="n">DateString</span><span class="p">,</span> <span class="k">out</span> <span class="n">DayOfWeek</span> <span class="n">dayOfWeek</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">DateString</span> <span class="p">=</span> <span class="n">dateTime</span><span class="p">.</span><span class="n">ToString</span><span class="p">(</span><span class="s">&quot;yyyy-MM-dd&quot;</span><span class="p">);</span>
        <span class="n">dayOfWeek</span> <span class="p">=</span> <span class="n">dateTime</span><span class="p">.</span><span class="n">DayOfWeek</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
如果类型提供了解构方法，你又在扩展方法中定义了与签名相同的解构方法，则编译器会优先选用类型提供的解构方法</p>
<h3 id="_16">局部函数<a class="headerlink" href="#_16" title="Permanent link">&para;</a></h3>
<p>局部函数（local functions）和匿名方法很像，当你有一个只会使用一次的函数（通常作为其他函数的辅助函数）时，可以使用局部函数或匿名方法。如下是一个利用局部函数和元组计算斐波那契数列的例子：</p>
<div class="codehilite"><pre><span></span><span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WriteLine</span><span class="p">(</span><span class="n">Fibonacci</span><span class="p">(</span><span class="m">10</span><span class="p">));</span>
    <span class="n">ReadKey</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Fibonacci</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&quot;输入正整数&quot;</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
    <span class="k">return</span> <span class="nf">Fib</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">current</span><span class="p">;</span>

    <span class="c1">// 局部函数定义</span>
    <span class="p">(</span><span class="kt">int</span> <span class="n">current</span><span class="p">,</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">)</span> <span class="n">Fib</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="p">==</span> <span class="m">1</span><span class="p">)</span> <span class="k">return</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="kt">var</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pp</span><span class="p">)</span> <span class="p">=</span> <span class="n">Fib</span><span class="p">(</span><span class="n">i</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">p</span> <span class="p">+</span> <span class="n">pp</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>局部函数是属于定义该函数的方法的，在上面的例子中，Fib函数只在Fibonacci方法中可用</p>
<ul>
<li>局部函数只能在方法体中使用</li>
<li>不能在匿名方法中使用</li>
<li>只能用async和unsafe修饰局部函数，不能使用访问修饰符，默认是私有、静态的</li>
<li>局部函数和某普通方法签名相同，局部函数会将普通方法隐藏，局部函数所在的外部方法调用时，只会调用到局部函数</li>
</ul>
<h3 id="_17">更多的表达式体成员<a class="headerlink" href="#_17" title="Permanent link">&para;</a></h3>
<p>C#6允许类型的定义中，字段后跟表达式作为默认值。C#7进一步允许了构造函数、getter、setter以及析构函数后跟表达式：</p>
<p><div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">CSharpSevenClass</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
    <span class="c1">// get, set使用表达式</span>
    <span class="kt">string</span> <span class="n">b</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">b</span><span class="p">;</span>
        <span class="k">set</span> <span class="p">=&gt;</span> <span class="n">b</span> <span class="p">=</span> <span class="s">&quot;12345&quot;</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="c1">// 构造函数</span>
    <span class="n">CSharpSevenClass</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="c1">// 析构函数</span>
    <span class="p">~</span><span class="n">CSharpSevenClass</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">a</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
上面的代码演示了所有C#7中允许后跟表达式（但过去版本不允许）的类型实例成员</p>
<h2 id="c_8">C# 8<a class="headerlink" href="#c_8" title="Permanent link">&para;</a></h2>
<h3 id="_18">可空引用类型<a class="headerlink" href="#_18" title="Permanent link">&para;</a></h3>
<p>从此，引用类型将会区分是否可分，可以从根源上解决 NullReferenceException。但是由于这个特性会打破兼容性，因此没有当作 error 来对待，而是使用 warning 折衷，而且开发人员需要手动 opt-in 才可以使用该特性（可以在项目层级或者文件层级进行设定）。
例如：</p>
<p><div class="codehilite"><pre><span></span><span class="kt">string</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// 产生警告: 对不可空引用类型赋值 null</span>
<span class="kt">string?</span> <span class="n">s</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// Ok</span>

<span class="k">void</span> <span class="nf">M</span><span class="p">(</span><span class="kt">string?</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// 产生警告：可能为 null</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span> <span class="c1">// Ok</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
至此，妈妈再也不用担心我的程序到处报 NullReferenceException 啦！</p>
<h3 id="async_streams">异步流（Async streams）<a class="headerlink" href="#async_streams" title="Permanent link">&para;</a></h3>
<p>考虑到大部分 Api 以及函数实现都有了对应的 async版本，而 IEnumerable<T>和 IEnumerator<T>还不能方便的使用 async/await就显得很麻烦了。
但是，现在引入了异步流，这些问题得到了解决。
我们通过新的 IAsyncEnumerable<T>和 IAsyncEnumerator<T>来实现这一点。同时，由于之前 foreach是基于IEnumerable<T>和 IEnumerator<T>实现的，因此引入了新的语法await foreach来扩展 foreach的适用性。
例如：</p>
<div class="codehilite"><pre><span></span><span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetBigResultAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="k">await</span> <span class="n">GetResultAsync</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">&gt;</span> <span class="m">20</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span> 
    <span class="k">else</span> <span class="k">return</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span> <span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">GetBigResultsAsync</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">await</span> <span class="nf">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">result</span> <span class="k">in</span> <span class="n">GetResultsAsync</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">&gt;</span> <span class="m">20</span><span class="p">)</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="_19">范围和下标类型<a class="headerlink" href="#_19" title="Permanent link">&para;</a></h3>
<p>C# 8.0 引入了 Index 类型，可用作数组下标，并且使用 ^ 操作符表示倒数。
不过要注意的是，倒数是从 1 开始的。</p>
<div class="codehilite"><pre><span></span><span class="n">Index</span> <span class="n">i1</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>  <span class="c1">// 下标为 3</span>
<span class="n">Index</span> <span class="n">i2</span> <span class="p">=</span> <span class="p">^</span><span class="m">4</span><span class="p">;</span> <span class="c1">// 倒数第 4 个元素</span>
<span class="kt">int</span><span class="p">[]</span> <span class="n">a</span> <span class="p">=</span> <span class="p">{</span> <span class="m">0</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">3</span><span class="p">,</span> <span class="m">4</span><span class="p">,</span> <span class="m">5</span><span class="p">,</span> <span class="m">6</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">8</span><span class="p">,</span> <span class="m">9</span> <span class="p">};</span>
<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;{a[i1]}, {a[i2]}&quot;</span><span class="p">);</span> <span class="c1">// &quot;3, 6&quot;</span>
</pre></div>

<p>除此之外，还引入了 “..” 操作符用来表示范围（注意是左闭右开区间）。</p>
<p><div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">slice</span> <span class="p">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i1</span><span class="p">..</span><span class="n">i2</span><span class="p">];</span> <span class="c1">// { 3, 4, 5 }</span>
</pre></div>
关于这个下标从 0 开始，倒数从 1 开始，范围左闭右开，笔者刚开始觉得很奇怪，但是发现 Python 等语言早已经做了这样的实践，并且效果不错。因此这次微软也采用了这种方式设计了 C# 8.0 的这个语法。</p>
<h3 id="_20">接口的默认实现方法<a class="headerlink" href="#_20" title="Permanent link">&para;</a></h3>
<p>从此接口中可以包含实现了：</p>
<div class="codehilite"><pre><span></span><span class="k">interface</span> <span class="n">ILogger</span>
<span class="p">{</span>
    <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">);</span>
    <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span><span class="n">Exception</span> <span class="n">ex</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">Log</span><span class="p">(</span><span class="n">LogLevel</span><span class="p">.</span><span class="n">Error</span><span class="p">,</span> <span class="n">ex</span><span class="p">.</span><span class="n">ToString</span><span class="p">());</span> <span class="c1">// 这是一个默认实现重载</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">ConsoleLogger</span> <span class="p">:</span> <span class="n">ILogger</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">void</span> <span class="nf">Log</span><span class="p">(</span><span class="n">LogLevel</span> <span class="n">level</span><span class="p">,</span> <span class="kt">string</span> <span class="n">message</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
    <span class="c1">// Log(Exception) 会得到执行的默认实现</span>
<span class="p">}</span>
</pre></div>

<p>在上面的例子中，Log(Exception)将会得到执行的默认实现。</p>
<h3 id="_21">模式匹配表达式和递归模式语句<a class="headerlink" href="#_21" title="Permanent link">&para;</a></h3>
<p>现在可以这么写了（patterns 里可以包含 patterns）</p>
<div class="codehilite"><pre><span></span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="n">GetEnrollees</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">p</span> <span class="k">in</span> <span class="n">People</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="k">is</span> <span class="n">Student</span> <span class="p">{</span> <span class="n">Graduated</span><span class="p">:</span> <span class="k">false</span><span class="p">,</span> <span class="n">Name</span><span class="p">:</span> <span class="kt">string</span> <span class="n">name</span> <span class="p">})</span> <span class="k">yield</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>Student { Graduated: false, Name: string name }检查 p 是否为 Graduated = false且 Name为 string的 Student，并且迭代返回 name。
可以这样写之后是不是很爽？</p>
<p>更有：</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">area</span> <span class="p">=</span> <span class="n">figure</span> <span class="k">switch</span> 
<span class="p">{</span>
    <span class="n">Line</span> <span class="n">_</span>      <span class="p">=&gt;</span> <span class="m">0</span><span class="p">,</span>
    <span class="n">Rectangle</span> <span class="n">r</span> <span class="p">=&gt;</span> <span class="n">r</span><span class="p">.</span><span class="n">Width</span> <span class="p">*</span> <span class="n">r</span><span class="p">.</span><span class="n">Height</span><span class="p">,</span>
    <span class="n">Circle</span> <span class="n">c</span>    <span class="p">=&gt;</span> <span class="n">c</span><span class="p">.</span><span class="n">Radius</span> <span class="p">*</span> <span class="m">2.0</span> <span class="p">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span><span class="p">,</span>
    <span class="n">_</span>           <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">UnknownFigureException</span><span class="p">(</span><span class="n">figure</span><span class="p">)</span>
<span class="p">};</span>
</pre></div>

<p>典型的模式匹配语句，只不过没有用“match”关键字，而是沿用了
了“switch”关键字。
但是不得不说，一个字，爽！</p>
<h3 id="_22">目标类型推导<a class="headerlink" href="#_22" title="Permanent link">&para;</a></h3>
<p>以前我们写下面这种变量/成员声明的时候，大概最简单的写法就是：</p>
<p><div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">points</span> <span class="p">=</span> <span class="k">new</span> <span class="p">[]</span> <span class="p">{</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">),</span> <span class="k">new</span> <span class="n">Point</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="m">6</span><span class="p">)</span> <span class="p">};</span>

<span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_myList</span> <span class="p">=</span> <span class="k">new</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;();</span>
</pre></div>
现在我们可以这么写啦：</p>
<div class="codehilite"><pre><span></span><span class="n">Point</span><span class="p">[]</span> <span class="n">ps</span> <span class="p">=</span> <span class="p">{</span> <span class="k">new</span> <span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">4</span><span class="p">),</span> <span class="k">new</span> <span class="p">(</span><span class="m">3</span><span class="p">,-</span><span class="m">2</span><span class="p">),</span> <span class="k">new</span> <span class="p">(</span><span class="m">9</span><span class="p">,</span> <span class="m">5</span><span class="p">)</span> <span class="p">};</span>

<span class="k">private</span> <span class="n">List</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">_myList</span> <span class="p">=</span> <span class="k">new</span> <span class="p">();</span>
</pre></div>

<h2 id="c_9">C# 9<a class="headerlink" href="#c_9" title="Permanent link">&para;</a></h2>
<h3 id="_23">仅可初始化的属性<a class="headerlink" href="#_23" title="Permanent link">&para;</a></h3>
<p>对象的初始化器非常了不起。它们为客户端创建对象提供了一种非常灵活且易于阅读的格式，而且特别适合嵌套对象的创建，我们可以通过嵌套对象一次性创建整个对象树。下面是一个简单的例子：</p>
<p><div class="codehilite"><pre><span></span><span class="k">new</span> <span class="n">Person</span>
<span class="p">{</span>
    <span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Scott&quot;</span><span class="p">,</span>
    <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hunter&quot;</span>
<span class="p">}</span>
</pre></div>
对象初始化器还可以让程序员免于编写大量类型的构造样板代码，他们只需编写一些属性即可！</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>目前的一大限制是，属性必须是可变的，只有这样对象初始化器才能起作用，因为它们需要首先调用对象的构造函数（在这种情况下调用的是默认的无参构造函数），然后分配给属性设置器。
仅可初始化的属性可以解决这个问题！它们引入了init访问器。init访问器是set访问器的变体，它只能在对象初始化期间调用：</p>
<p><div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
在这种声明下，上述客户端代码仍然合法，但是后续如果你想为FirstName和LastName属性赋值就会出错。</p>
<h3 id="_24">初始化访问器和只读字段<a class="headerlink" href="#_24" title="Permanent link">&para;</a></h3>
<p>由于init访问器只能在初始化期间被调用，所以它们可以修改所在类的只读字段，就像构造函数一样。</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">;</span>
    <span class="k">private</span> <span class="k">readonly</span> <span class="kt">string</span> <span class="n">lastName</span><span class="p">;</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">firstName</span><span class="p">;</span>
        <span class="n">init</span> <span class="p">=&gt;</span> <span class="n">firstName</span> <span class="p">=</span> <span class="p">(</span><span class="k">value</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">FirstName</span><span class="p">)));</span>
    <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span>
    <span class="p">{</span>
        <span class="k">get</span> <span class="p">=&gt;</span> <span class="n">lastName</span><span class="p">;</span>
        <span class="n">init</span> <span class="p">=&gt;</span> <span class="n">lastName</span> <span class="p">=</span> <span class="p">(</span><span class="k">value</span> <span class="p">??</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">LastName</span><span class="p">)));</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h3 id="_25">记录<a class="headerlink" href="#_25" title="Permanent link">&para;</a></h3>
<p>如果你想保持某个属性不变，那么仅可初始化的属性非常有用。如果你希望整个对象都不可变，而且希望其行为宛如一个值，那么就应该考虑将其声明为记录：</p>
<p><div class="codehilite"><pre><span></span><span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>
上述类声明中的data关键字表明这是一个记录，因此它具备了其他一些类似于值的行为，后面我们将深入讨论。一般而言，我们更应该将记录视为“值”（数据），而非对象。它们不具备可变的封装状态。相反，你可以通过创建表示新状态的新记录来表示随着时间发生的变化。记录不是由标识确定，而是由其内容确定。</p>
<h3 id="with">With表达式<a class="headerlink" href="#with" title="Permanent link">&para;</a></h3>
<p>处理不可变数据时，一种常见的模式是利用现有的值创建新值以表示新状态。例如，如果想修改某人的姓氏，那么我们会用一个新对象来表示，这个对象除了姓氏之外和旧对象完全一样。通常我们称该技术为非破坏性修改。记录代表的不是某段时间的某个人，而是给定时间点上这个人的状态。
为了帮助大家习惯这种编程风格，记录允许使用一种新的表达方式：with表达式：</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">otherPerson</span> <span class="p">=</span> <span class="n">person</span> <span class="n">with</span> <span class="p">{</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hanselman&quot;</span> <span class="p">};</span>
</pre></div>

<p>with表达式使用对象初始化的语法来说明新对象与旧对象之间的区别。你可以指定多个属性。
记录隐式地定义了一个protected“复制构造函数”，这种构造函数利用现有的记录对象，将字段逐个复制到新的记录对象中：</p>
<p><div class="codehilite"><pre><span></span><span class="k">protected</span> <span class="nf">Person</span><span class="p">(</span><span class="n">Person</span> <span class="n">original</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* copy all the fields */</span> <span class="p">}</span> <span class="c1">// generated</span>
</pre></div>
with表达式会调用复制构造函数，然后在其上应用对象初始化器，以相应地更改属性。
如果你不喜欢自动生成的复制构造函数，那么也可以自己定义，with表达式就会调用自定义的复制构造函数。</p>
<h3 id="_26">基于值的相等<a class="headerlink" href="#_26" title="Permanent link">&para;</a></h3>
<p>所有对象都会从object类继承一个虚的Equals(object)方法。在调用静态方法Object.Equals(object, object)且两个参数均不为null时，该Equals(object)就会被调用。</p>
<p>结构体可以重载这个方法，获得“基于值的相等性”，即递归调用Equals来比较结构的每个字段。记录也一样。
这意味着，如果两个记录对象的值一致，则二者相等，但两者不一定是同一对象。例如，如果我们再次修改前面那个人的姓氏：</p>
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">originalPerson</span> <span class="p">=</span> <span class="n">otherPerson</span> <span class="n">with</span> <span class="p">{</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hunter&quot;</span> <span class="p">};</span>
</pre></div>

<p>现在，ReferenceEquals(person, originalPerson) = false（它们不是同一个对象），但Equals(person, originalPerson) = true （它们拥有相同的值）。
如果你不喜欢自动生成的Equals覆盖默认的逐字段比较的行为，则可以编写自己的Equals重载。你只需要确保你理解基于值的相等性在记录中的工作原理，尤其是在涉及继承的情况下，具体的内容我们稍后再做介绍。
除了基于值的Equals之外，还有一个基于值的GetHashCode()重载方法。</p>
<h3 id="_27">数据成员<a class="headerlink" href="#_27" title="Permanent link">&para;</a></h3>
<p>在绝大多数情况下，记录都是不可变的，它们的仅可初始化的属性是公开的，可以通过with表达式进行非破坏性修改。为了优化这种最常见的情况，我们改变了记录中类似于string FirstName这种成员声明的默认含义。在其他类和结构声明中，这种声明表示私有字段，但在记录中，这相当于公开的、仅可初始化的自动属性！因此，如下声明：</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="kt">string</span> <span class="n">FirstName</span><span class="p">;</span> <span class="kt">string</span> <span class="n">LastName</span><span class="p">;</span> <span class="p">}</span>
</pre></div>

<p>与之前提到过的下述声明完全相同：</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">FirstName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">public</span> <span class="kt">string</span> <span class="n">LastName</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="n">init</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<p>我们认为这种方式可以让记录更加优美而清晰。如果你需要私有字段，则可以明确添加private修饰符：</p>
<div class="codehilite"><pre><span></span><span class="k">private</span> <span class="kt">string</span> <span class="n">firstName</span><span class="p">;</span>
</pre></div>

<h3 id="_28">位置记录<a class="headerlink" href="#_28" title="Permanent link">&para;</a></h3>
<p>有时，用参数位置来声明记录会很有用，内容可以根据构造函数参数的位置来指定，并且可以通过位置解构来提取。
你完全可以在记录中指定自己的构造函数和析构函数：</p>
<p><code>C#
public data class Person 
{ 
    string FirstName; 
    string LastName; 
    public Person(string firstName, string lastName) 
      =&gt; (FirstName, LastName) = (firstName, lastName);
    public void Deconstruct(out string firstName, out string lastName) 
      =&gt; (firstName, lastName) = (FirstName, LastName);
}</code>
但是，我们可以用更短的语法表达完全相同的内容（使用成员变量的大小写方式来命名参数）：</p>
<p><div class="codehilite"><pre><span></span><span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nf">Person</span><span class="p">(</span><span class="kt">string</span> <span class="n">FirstName</span><span class="p">,</span> <span class="kt">string</span> <span class="n">LastName</span><span class="p">);</span>
</pre></div>
上述声明了仅可初始化的公开的自动属性以及构造函数和析构函数，因此你可以这样写：
<div class="codehilite"><pre><span></span><span class="kt">var</span> <span class="n">person</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Person</span><span class="p">(</span><span class="s">&quot;Scott&quot;</span><span class="p">,</span> <span class="s">&quot;Hunter&quot;</span><span class="p">);</span> <span class="c1">// positional construction</span>
<span class="kt">var</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="p">=</span> <span class="n">person</span><span class="p">;</span>                        <span class="c1">// positional deconstruction</span>
</pre></div>
如果你不喜欢生成的自动属性，则可以定义自己的同名属性，这样生成的构造函数和析构函数就会自动使用自己定义的属性。</p>
<h3 id="_29">记录和修改<a class="headerlink" href="#_29" title="Permanent link">&para;</a></h3>
<p>记录的语义是基于值的，因此在可变的状态中无法很好地使用。想象一下，如果我们将记录对象放入字典，那么就只能通过Equals和GethashCode找到了。但是，如果记录更改了状态，那么在判断相等时它代表的值也会发生改变！可能我们就找不到它了！在哈希表的实现中，这个性质甚至可能破坏数据结构，因为数据的存放位置是根据它“到达”哈希表时的哈希值决定的！
而且，记录也可能有一些使用内部可变状态的高级方法，这些方法完全是合理的，例如缓存。但是可以考虑通过手工重载默认的行为来忽略这些状态。</p>
<h3 id="with_1">with表达式和继承<a class="headerlink" href="#with_1" title="Permanent link">&para;</a></h3>
<p>众所周知，考虑继承时基于值的相等性和非破坏性修改是一个难题。下面我们在示例中添加一个继承的记录类Student：
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nc">Person</span> <span class="p">{</span> <span class="kt">string</span> <span class="n">FirstName</span><span class="p">;</span> <span class="kt">string</span> <span class="n">LastName</span><span class="p">;</span> <span class="p">}</span>
<span class="k">public</span> <span class="n">data</span> <span class="k">class</span> <span class="nc">Student</span> <span class="p">:</span> <span class="n">Person</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">ID</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
在如下with表达式的示例中，我们实际创建一个Student，然后将其存储到Person变量中：
<div class="codehilite"><pre><span></span><span class="n">Person</span> <span class="n">person</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Student</span> <span class="p">{</span> <span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Scott&quot;</span><span class="p">,</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hunter&quot;</span><span class="p">,</span> <span class="n">ID</span> <span class="p">=</span> <span class="n">GetNewId</span><span class="p">()</span> <span class="p">};</span>
<span class="n">otherPerson</span> <span class="p">=</span> <span class="n">person</span> <span class="n">with</span> <span class="p">{</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hanselman&quot;</span> <span class="p">};</span>
</pre></div></p>
<p>在最后一行的with表达式中，编译器并不知道person实际上包含一个Student。而且，即使otherPerson不是Student对象，它也不是合法的副本，因为它包含了与第一个对象相同的ID属性。
C#解决了这个问题。记录有一个隐藏的虚方法，能够确保“克隆”整个对象。每个继承的记录类型都会通过重载这个方法来调用该类型的复制构造函数，而继承记录的复制构造函数会调用基类的复制构造函数。with表达式只需调用这个隐藏“clone”方法，然后在结果上应用对象初始化器即可。</p>
<h3 id="_30">基于值的相等性与继承<a class="headerlink" href="#_30" title="Permanent link">&para;</a></h3>
<p>与with表达式的支持类似，基于值的相等性也必须是“虚的”，即两个Student对象比较时需要比较所有字段，即使在比较时，能够静态地得知类型是基类，比如Person。这一点通过重写已经是虚方法的Equals方法可以轻松实现。
然而，相等性还有另外一个难题：如果需要比较两个不同类型的Person怎么办？我们不能简单地选择其中一个来决定是否相等：相等性应该是对称的，因此无论两个对象中的哪个首先出现，结果都应该相同。换句话说，二者之间必须就相等性达成一致！
我们来举例说明这个问题：
<div class="codehilite"><pre><span></span><span class="n">Person</span> <span class="n">person1</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Person</span> <span class="p">{</span> <span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Scott&quot;</span><span class="p">,</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hunter&quot;</span> <span class="p">};</span>
<span class="n">Person</span> <span class="n">person2</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Student</span> <span class="p">{</span> <span class="n">FirstName</span> <span class="p">=</span> <span class="s">&quot;Scott&quot;</span><span class="p">,</span> <span class="n">LastName</span> <span class="p">=</span> <span class="s">&quot;Hunter&quot;</span><span class="p">,</span> <span class="n">ID</span> <span class="p">=</span> <span class="n">GetNewId</span><span class="p">()</span> <span class="p">};</span>
</pre></div>
这两个对象彼此相等吗？person1可能会认为相等，因为person2拥有Person的所有字段，但person2可能会有不同的看法！我们需要确保二者都认同它们是不同的对象。
C#可以自动为你解决这个问题。具体的实现方式是：记录拥有一个名为EqualityContract的受保护虚属性。每个继承的记录都会重载这个属性，而且为了比较相等，两个对象必须具有相同的EqualityContract。</p>
<h3 id="_31">顶级程序<a class="headerlink" href="#_31" title="Permanent link">&para;</a></h3>
<p>使用C#编写一个简单的程序需要大量的样板代码：</p>
<p><div class="codehilite"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Program</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
这不仅对初学者来说难度太高，而且代码混乱，缩进级别也太多。
在C# 9.0中，你只需编写顶层的主程序：
<div class="codehilite"><pre><span></span><span class="k">using</span> <span class="nn">System</span><span class="p">;</span>

<span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&quot;Hello World!&quot;</span><span class="p">);</span>
</pre></div>
任何语句都可以。程序必须位于using之后，文件中的任何类型或名称空间声明之前，而且只能在一个文件中，就像只有一个Main方法一样。
如果你想返回状态代码，则可以利用这种写法。如果你想await，那么也可以这么写。此外，如果你想访问命令行参数，则args可作为“魔术”参数使用。
局部函数是语句的一种形式，而且也可以在顶层程序中使用。在顶层语句之外的任何地方调用局部函数都会报错。</p>
<h3 id="_32">改进后的模式匹配<a class="headerlink" href="#_32" title="Permanent link">&para;</a></h3>
<p>C# 9.0中添加了几种新的模式。下面我们通过如下模式匹配教程的代码片段来看看这些新模式：</p>
<div class="codehilite"><pre><span></span><span class="k">public</span> <span class="k">static</span> <span class="kt">decimal</span> <span class="nf">CalculateToll</span><span class="p">(</span><span class="kt">object</span> <span class="n">vehicle</span><span class="p">)</span> <span class="p">=&gt;</span>
    <span class="n">vehicle</span> <span class="k">switch</span>
    <span class="p">{</span>
       <span class="p">...</span>

        <span class="n">DeliveryTruck</span> <span class="n">t</span> <span class="n">when</span> <span class="n">t</span><span class="p">.</span><span class="n">GrossWeightClass</span> <span class="p">&gt;</span> <span class="m">5000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">+</span> <span class="m">5.00</span><span class="n">m</span><span class="p">,</span>
        <span class="n">DeliveryTruck</span> <span class="n">t</span> <span class="n">when</span> <span class="n">t</span><span class="p">.</span><span class="n">GrossWeightClass</span> <span class="p">&lt;</span> <span class="m">3000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">-</span> <span class="m">2.00</span><span class="n">m</span><span class="p">,</span>
        <span class="n">DeliveryTruck</span> <span class="n">_</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span><span class="p">,</span>

        <span class="n">_</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="s">&quot;Not a known vehicle type&quot;</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">vehicle</span><span class="p">))</span>
    <span class="p">};</span>
</pre></div>

<h3 id="_33">简单类型模式<a class="headerlink" href="#_33" title="Permanent link">&para;</a></h3>
<p>当前，类型模式需要在类型匹配时声明一个标识符，即使该标识符是表示放弃的_也可以，如上面的DeliveryTruck _。而如今你可以像下面这样编写类型：
<div class="codehilite"><pre><span></span><span class="n">DeliveryTruck</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span><span class="p">,</span>
</pre></div></p>
<h3 id="_34">关系模式<a class="headerlink" href="#_34" title="Permanent link">&para;</a></h3>
<p>C# 9.0中引入了与关系运算符&lt;、&lt;=等相对应的模式。因此，你可以将上述模式的DeliveryTruck写成嵌套的switch表达式：</p>
<p><div class="codehilite"><pre><span></span><span class="n">DeliveryTruck</span> <span class="n">t</span> <span class="n">when</span> <span class="n">t</span><span class="p">.</span><span class="n">GrossWeightClass</span> <span class="k">switch</span>
<span class="p">{</span>
    <span class="p">&gt;</span> <span class="m">5000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">+</span> <span class="m">5.00</span><span class="n">m</span><span class="p">,</span>
    <span class="p">&lt;</span> <span class="m">3000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">-</span> <span class="m">2.00</span><span class="n">m</span><span class="p">,</span>
    <span class="n">_</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>
这的 &gt; 5000 和 &lt; 3000是关系模式。</p>
<h3 id="_35">逻辑模式<a class="headerlink" href="#_35" title="Permanent link">&para;</a></h3>
<p>最后，你还可以将模式与逻辑运算符（and、or和not）组合在一起，它们以英文单词的形式出现，以避免与表达式中使用的运算符混淆。例如，上述嵌套的switch表达式可以按照升序写成下面这样：</p>
<div class="codehilite"><pre><span></span><span class="n">DeliveryTruck</span> <span class="n">t</span> <span class="n">when</span> <span class="n">t</span><span class="p">.</span><span class="n">GrossWeightClass</span> <span class="k">switch</span>
<span class="p">{</span>
    <span class="p">&lt;</span> <span class="m">3000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">-</span> <span class="m">2.00</span><span class="n">m</span><span class="p">,</span>
    <span class="p">&gt;=</span> <span class="m">3000</span> <span class="n">and</span> <span class="p">&lt;=</span> <span class="m">5000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span><span class="p">,</span>
    <span class="p">&gt;</span> <span class="m">5000</span> <span class="p">=&gt;</span> <span class="m">10.00</span><span class="n">m</span> <span class="p">+</span> <span class="m">5.00</span><span class="n">m</span><span class="p">,</span>
<span class="p">},</span>
</pre></div>

<p>中间一行通过and将两个关系模式组合到一起，形成了表示间隔的模式。
not模式的常见用法也可应用于null常量模式，比如not null。例如，我们可以根据是否为null来拆分未知情况的处理方式：</p>
<p><div class="codehilite"><pre><span></span><span class="n">not</span> <span class="k">null</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentException</span><span class="p">(</span><span class="err">$</span><span class="s">&quot;Not a known vehicle type: {vehicle}&quot;</span><span class="p">,</span> <span class="n">nameof</span><span class="p">(</span><span class="n">vehicle</span><span class="p">)),</span>
<span class="k">null</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="n">ArgumentNullException</span><span class="p">(</span><span class="n">nameof</span><span class="p">(</span><span class="n">vehicle</span><span class="p">))</span>
</pre></div>
此外，如果if条件中包含is表达式，那么使用not也很方便，可以避免笨拙的双括号：</p>
<p><div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(!(</span><span class="n">e</span> <span class="k">is</span> <span class="n">Customer</span><span class="p">))</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div>
你可以这样写：
<div class="codehilite"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="n">e</span> <span class="k">is</span> <span class="n">not</span> <span class="n">Customer</span><span class="p">)</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
</pre></div></p>
<h3 id="_36">改进后的目标类型推断<a class="headerlink" href="#_36" title="Permanent link">&para;</a></h3>
<p>“目标类型推断”指的是表达式从所在的上下文中获取类型。例如，null和lambda表达式始终是目标类型推断。
在C# 9.0中，有些以前不是目标类型推断的表达式也可以通过上下文来判断类型。</p>
<h3 id="new">支持目标类型推断的new表达式<a class="headerlink" href="#new" title="Permanent link">&para;</a></h3>
<p>C# 中的new表达式始终要求指定类型（隐式类型的数组表达式除外）。现在， 如果有明确的类型可以分配给表达式，则可以省去指定类型。
<div class="codehilite"><pre><span></span><span class="n">Point</span> <span class="n">p</span> <span class="p">=</span> <span class="k">new</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span> <span class="m">5</span><span class="p">);</span>
</pre></div></p>
<h3 id="_37">目标类型的??与?:<a class="headerlink" href="#_37" title="Permanent link">&para;</a></h3>
<p>有时，条件判断表达式中??与?:的各个分支之间并不是很明显的同一种类型。现在这种情况会出错，但在C# 9.0中，如果两个分支都可以转换为目标类型，就没有问题：
<div class="codehilite"><pre><span></span><span class="n">Person</span> <span class="n">person</span> <span class="p">=</span> <span class="n">student</span> <span class="p">??</span> <span class="n">customer</span><span class="p">;</span> <span class="c1">// Shared base type</span>
<span class="kt">int?</span> <span class="n">result</span> <span class="p">=</span> <span class="n">b</span> <span class="p">?</span> <span class="m">0</span> <span class="p">:</span> <span class="k">null</span><span class="p">;</span> <span class="c1">// nullable value type</span>
</pre></div></p>
<h3 id="_38">支持协变的返回值<a class="headerlink" href="#_38" title="Permanent link">&para;</a></h3>
<p>有时，我们需要表示出继承类中重载的某个方法的返回类型要比基类中的类型更具体。C# 9.0允许以下写法：</p>
<div class="codehilite"><pre><span></span><span class="k">abstract</span> <span class="k">class</span> <span class="nc">Animal</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">abstract</span> <span class="n">Food</span> <span class="nf">GetFood</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
<span class="k">class</span> <span class="nc">Tiger</span> <span class="p">:</span> <span class="n">Animal</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">override</span> <span class="n">Meat</span> <span class="nf">GetFood</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="p">...;</span>
<span class="p">}</span>
</pre></div>

<p>总结
上面80%我认为都是比较有用的新特性，后面的几个我觉得用处不大，当然如果找到合适的使用场景应该有用，欢迎大家补充。
最后，祝大家编程愉快。</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../.." title="介绍" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  上一页
                </span>
                介绍
              </span>
            </div>
          </a>
        
        
          <a href="../c_docker/" title=".Net Core Docker 部署" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  下一页
                </span>
                .Net Core Docker 部署
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            BurningMyself 蜀ICP备15033200号-1
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
  <div class="md-footer-social">
    <link rel="stylesheet" href="../../assets/fonts/font-awesome.css">
    
      <a href="https://github.com/burningmyself" class="md-footer-social__link fa fa-github"></a>
    
      <a href="https://gitee.com/burningmyself" class="md-footer-social__link fa fa-google"></a>
    
  </div>

    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.808e90bb.js"></script>
      
        
        
          
          <script src="../../assets/javascripts/lunr/lunr.stemmer.support.js"></script>
          
            
              
              
            
          
            
          
            
              
                <script src="../../assets/javascripts/lunr/tinyseg.js"></script>
              
              
                <script src="../../assets/javascripts/lunr/lunr.ja.js"></script>
              
            
          
          
            <script src="../../assets/javascripts/lunr/lunr.multi.js"></script>
          
        
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
        <script src="../../js/extra.js"></script>
      
        <script src="../../js/baidu-tongji.js"></script>
      
    
  </body>
</html>